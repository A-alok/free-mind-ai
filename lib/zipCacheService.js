// lib/zipCacheService.js
import { uploadZipToCloudinary } from './cloudinary.js';
import connectDB from './mongodb.js';
import CodeZip from '../models/codeZip.js';

/**
 * Service to handle caching of zip files generated by Flask backend
 */
export class ZipCacheService {
    constructor() {
        this.cache = new Map(); // In-memory cache for quick lookups
    }

    /**
     * Generate a cache key from filename
     * @param {string} filename - Original filename from Flask
     * @returns {string} - Cache key
     */
    generateCacheKey(filename) {
        // Remove file extension and any extra characters
        return filename.replace(/\.(zip|tar|gz)$/i, '').toLowerCase();
    }

    /**
     * Extract project information from filename
     * @param {string} filename - Original filename
     * @returns {Object} - Project metadata
     */
    extractProjectInfo(filename) {
        // Parse filename like: project_a87a1d42-a4bc-41a4-9bd8-f6e94fae9870.zip
        const baseName = filename.replace(/\.(zip|tar|gz)$/i, '');
        
        // Try to extract project name and ID
        const match = baseName.match(/^(.+?)_([a-f0-9\-]{36})$/i);
        
        if (match) {
            return {
                projectName: match[1].replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
                projectId: match[2],
                originalFilename: filename
            };
        }
        
        // Fallback for other filename patterns
        return {
            projectName: baseName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
            projectId: null,
            originalFilename: filename
        };
    }

    /**
     * Check if zip file exists in Cloudinary/MongoDB
     * @param {string} filename - Original filename
     * @param {string} userId - User ID (optional)
     * @returns {Promise<Object|null>} - CodeZip document if found
     */
    async checkCache(filename, userId = null) {
        try {
            await connectDB();
            
            const cacheKey = this.generateCacheKey(filename);
            
            // Check in-memory cache first
            if (this.cache.has(cacheKey)) {
                const cached = this.cache.get(cacheKey);
                // Check if cache entry is still valid (not expired)
                if (new Date() < new Date(cached.expiresAt)) {
                    console.log('ðŸ“‹ Found in memory cache:', filename);
                    return cached;
                }
                // Remove expired entry
                this.cache.delete(cacheKey);
            }

            // Check MongoDB
            const query = {
                $or: [
                    { zipFileName: filename },
                    { zipFileName: { $regex: cacheKey, $options: 'i' } },
                    { 'generationParameters.originalFilename': filename }
                ],
                status: 'active'
            };

            // Add user filter if provided
            if (userId) {
                query.$or = [
                    { ...query, userId },
                    { ...query, isPublic: true }
                ];
            }

            const existing = await CodeZip.findOne(query).sort({ createdAt: -1 });
            
            if (existing && !existing.isExpired()) {
                // Add to in-memory cache
                this.cache.set(cacheKey, existing);
                console.log('ðŸ“‹ Found in MongoDB cache:', filename);
                return existing;
            }

            console.log('ðŸ“‹ No valid cache entry found for:', filename);
            return null;

        } catch (error) {
            console.error('Error checking cache:', error);
            return null;
        }
    }

    /**
     * Store zip file in Cloudinary and MongoDB
     * @param {Buffer} zipBuffer - Zip file buffer
     * @param {string} originalFilename - Original filename from Flask
     * @param {string} userId - User ID (optional)
     * @param {Object} metadata - Additional metadata
     * @returns {Promise<Object>} - Stored CodeZip document
     */
    async storeZip(zipBuffer, originalFilename, userId = null, metadata = {}) {
        try {
            const projectInfo = this.extractProjectInfo(originalFilename);
            const cacheKey = this.generateCacheKey(originalFilename);

            console.log('ðŸ’¾ Storing zip in cache:', originalFilename);

            // Upload to Cloudinary
            const cloudinaryResult = await uploadZipToCloudinary(
                zipBuffer,
                originalFilename,
                userId || 'anonymous'
            );

            // Prepare MongoDB document
            await connectDB();
            
            const codeZipData = {
                projectName: metadata.projectName || projectInfo.projectName,
                projectDescription: metadata.projectDescription || `Generated project: ${projectInfo.projectName}`,
                userId: userId,
                userEmail: metadata.userEmail || null,
                zipFileName: originalFilename,
                zipSize: zipBuffer.length,
                cloudinaryUrl: cloudinaryResult.url,
                cloudinaryPublicId: cloudinaryResult.publicId,
                cloudinaryFolder: cloudinaryResult.folder,
                cloudinaryCreatedAt: new Date(cloudinaryResult.createdAt),
                generatedFiles: metadata.generatedFiles || [],
                techStack: metadata.techStack || [],
                generationParameters: {
                    model: 'flask-backend',
                    originalFilename: originalFilename,
                    projectId: projectInfo.projectId,
                    cachedAt: new Date(),
                    ...metadata.generationParameters
                },
                tags: ['flask-generated', 'cached', ...(metadata.tags || [])],
                isPublic: metadata.isPublic || false,
                expiresAt: new Date(Date.now() + (metadata.expirationDays || 30) * 24 * 60 * 60 * 1000)
            };

            const codeZip = new CodeZip(codeZipData);
            await codeZip.save();

            // Add to in-memory cache
            this.cache.set(cacheKey, codeZip);

            console.log('âœ… Zip stored in cache:', codeZip._id);

            return {
                success: true,
                codeZip,
                cloudinaryUrl: cloudinaryResult.url,
                cached: true
            };

        } catch (error) {
            console.error('Error storing zip in cache:', error);
            throw error;
        }
    }

    /**
     * Get zip file - either from cache or fetch from Flask and cache it
     * @param {string} filename - Original filename
     * @param {string} userId - User ID (optional)
     * @param {Object} options - Additional options
     * @returns {Promise<Object>} - Zip file info with buffer or URL
     */
    async getZip(filename, userId = null, options = {}) {
        try {
            // First check if we have it cached
            const cached = await this.checkCache(filename, userId);
            
            if (cached && cached.cloudinaryUrl) {
                // Increment download count
                await cached.incrementDownloadCount();
                
                console.log('ðŸš€ Serving from cache:', filename);
                return {
                    source: 'cache',
                    url: cached.cloudinaryUrl,
                    codeZip: cached,
                    filename: cached.zipFileName
                };
            }

            // If not cached, we'll need the caller to provide the zip buffer
            // This method is used in conjunction with the download endpoint
            console.log('ðŸ”„ Cache miss for:', filename);
            return {
                source: 'flask',
                cached: false,
                filename: filename
            };

        } catch (error) {
            console.error('Error getting zip:', error);
            return {
                source: 'flask',
                cached: false,
                filename: filename,
                error: error.message
            };
        }
    }

    /**
     * Cache a zip file that was fetched from Flask
     * @param {Buffer} zipBuffer - Zip file buffer from Flask
     * @param {string} filename - Original filename
     * @param {string} userId - User ID (optional)
     * @param {Object} metadata - Additional metadata
     * @returns {Promise<Object>} - Cache result
     */
    async cacheFlaskZip(zipBuffer, filename, userId = null, metadata = {}) {
        try {
            // Extract additional metadata if possible
            const enhancedMetadata = {
                ...metadata,
                generationParameters: {
                    source: 'flask-backend',
                    originalFilename: filename,
                    cachedAt: new Date(),
                    ...metadata.generationParameters
                }
            };

            return await this.storeZip(zipBuffer, filename, userId, enhancedMetadata);

        } catch (error) {
            console.error('Error caching Flask zip:', error);
            // Don't throw error - just log it and return info about the failure
            return {
                success: false,
                error: error.message,
                cached: false
            };
        }
    }

    /**
     * Clean up expired cache entries
     * @returns {Promise<Object>} - Cleanup stats
     */
    async cleanupCache() {
        try {
            // Clear in-memory cache of expired entries
            const now = new Date();
            let memoryCleared = 0;
            
            for (const [key, entry] of this.cache.entries()) {
                if (new Date(entry.expiresAt) < now) {
                    this.cache.delete(key);
                    memoryCleared++;
                }
            }

            console.log(`ðŸ§¹ Cleaned up ${memoryCleared} expired memory cache entries`);

            return {
                memoryCleared,
                message: `Cleaned up ${memoryCleared} expired cache entries`
            };

        } catch (error) {
            console.error('Error cleaning up cache:', error);
            throw error;
        }
    }

    /**
     * Get cache statistics
     * @returns {Object} - Cache statistics
     */
    getCacheStats() {
        return {
            memoryCacheSize: this.cache.size,
            memoryCacheKeys: Array.from(this.cache.keys())
        };
    }
}

// Create singleton instance
const zipCacheService = new ZipCacheService();

export default zipCacheService;